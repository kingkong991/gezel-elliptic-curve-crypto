#ifndef WRAPPER_GF2M_FDL
#define WRAPPER_GF2M_FDL

#include "constants.inc"

#include "malu.fdl"

// Mode:	0 = addition
//			1 = multiplication

dp wrapper_gf2m (in A: ns(const_m);
	in B: ns(const_m);
	in start: ns(1);
	in mode: ns(1);
	out T: ns(const_m);
	out ready: ns(1)) {

	reg reg_start: ns(1);
	reg reg_mode: ns(1);

	reg reg_T: ns(const_m);
	reg reg_ready: ns(1);
	reg reg_m: ns(1);

	reg reg_cycle: ns(const_m_log);

	sig T_in: ns(const_m);
	sig B_in: ns(const_m);
	sig B_mux: ns(1);
	sig m_in: ns(1);
	sig m_mux: ns(1);

	sig T_out: ns(const_m);
	sig T_mux: ns(const_m);
	sig m_out: ns(1);

	sig sig_ready: ns(1);

	use malu(T_in, B_in, m_in, T_out, m_out);

	sfg do_always {
		reg_start = start;

		// Do it this way, so init doesn't waste a cycle.
		reg_mode = start == 1 ? mode : reg_mode;

		reg_cycle = start == 1 ? 0 : reg_cycle + 1;

		// Store data in reg_T:
		// When start is high, either set reg_T to 0 (multiplication) or A (addition)
		// Otherwise set reg_T to MALU_output or MALU_output shifted 1 to the left (so the result stays the same)
		T_mux = start == 1 : (mode == 0 ? A : 0) : (reg_ready == 1 ? m_out # ((ns(const_m - 1)) T_out[1:(const_m - 1)]) : T_out);
		reg_T = T_mux;
		T_in = reg_T;
		
		// Set output to the content of reg_T
		T = T_mux;
		
		// Set B input
		// If ready: AND 0, else if addition: AND 1, else if multiplication: AND last A bit 		
		B_mux = reg_ready == 1 ? 0 : (mode == 0 ? 1 : A[const_m - 1]);
		B_in = ANDMBITS(B_mux, B);
		
		// Set m register
		// If start of sig_ready is high, set m to 0, otherwise set to output from MALU
		m_in = reg_m;
		m_mux = ~(sig_ready | start) & m_out;
		reg_m = m_mux;

		// Set ready register and output:
		// When start is high and we go for addition, set ready to 1, result is ready in 1 cycle. When
		// doing multiplication, set to zero.
		//reg_ready = start == 1 ? (mode == 0 ? 1 : 0) : (sig_ready == 1 ? 1 : reg_ready);	// TODO: Make this a logical expression.
		/*
		 * Logic function, solution  of Quine-McCluskey: (!A*D)+(!A*C)+(A*!B)
		 => This is not optimal, you can save one gate by using: !A*(C+D) + A*!B
		 * With A = start, B = mode, C = sig_ready, D = reg_ready
		 */
		reg_ready = (~start & (reg_ready | sig_ready)) | (start & ~mode);
		ready = reg_ready;
	}

	sfg iteration {
		sig_ready = 0;
	
		//$display($bin, "A[const_m - 1] = ", A[const_m - 1], " - reg_m = ", reg_m, " - B_in = ", B_in, " - m_in = ", m_in, " - T_out = ", T_out, " - m_out = ", m_out);
	}

	sfg ready {
		sig_ready = 1;
	}

	sfg end_mult {
		sig_ready = 1;

		//$display("[MALU] [End Mult] Output = T - T = ", $bin, reg_T, " = ", $dec, reg_T);
	}
}

fsm fsm_wrapper_gf2m (wrapper_gf2m) {
	initial idle;
	state run;

	@idle	if (reg_start == 1) then 
				if (reg_mode == 1) then (iteration, do_always) -> run;	// Multiplication
				else (ready, do_always) -> idle;	// Addition
			else (do_always) -> idle;
	@run if (reg_cycle <= (const_m - 2)) then (iteration, do_always) -> run;
			else (ready, do_always) -> idle;
}

#endif /* WRAPPER_GF2M_FDL */
