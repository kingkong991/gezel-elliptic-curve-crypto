#ifndef MULT_MOD_FDL
#define MULT_MOD_FDL

#include "constants.inc"

#include "malu.fdl"

dp mult_mod (in A: ns(const_m);
	in B: ns(const_m);
	in start: ns(1);
	out T: ns(const_m);
	out ready: ns(1)) {

	reg reg_start: ns(1);MULT_MOD

	reg reg_T: ns(const_m);
	reg reg_ready: ns(1);
	reg reg_m: ns(1);

	reg reg_A: ns(const_m);
	reg reg_B: ns(const_m);

	reg cycle: ns(const_m);

	sig T_in: ns(const_m);
	sig B_in: ns(const_m);
	sig P_in: ns(const_m);

	sig T_out: ns(const_m);
	sig m_out: ns(1);

	use malu(T_in, B_in, T_out, m_out);

	sfg do_always {
		reg_start = start;

		T = reg_T;
		ready = reg_ready;
	}

	sfg init {
		cycle = 0;

		reg_A = A;
		reg_B = B;

		reg_ready = 0;
	}

	sfg idle {
		T_in = 0;
		B_in = 0;
		P_in = 0;
	}

	sfg iteration {
		T_in = reg_T;

		// And B & P instead of muxing: less area
		// reg_A[0] and reg_m are only ns(1), need to be copied const_m times.
		B_in = ANDMBITS(reg_A[0], reg_B);
		P_in = ANDMBITS(reg_m, reg_P);
		
		cycle = cycle + 1;

		reg_T = T_out;
		reg_m = m_out;

		reg_A = reg_A >> 1;
	}

	// "Divide" by x at the end
	sfg end {
		T_in = reg_T;

		B_in = ANDMBITS(reg_A[0], reg_B);
		P_in = ANDMBITS(reg_m, const_P);
		
		cycle = cycle + 1;

		reg_T = (ns(1)) m_out # reg_T[1:(const_m - 1)];
		reg_ready = 1;
	}
}

fsm fsm_mult_mod (mult_mod) {
	initial idle;
	state run;

	@idle	if (reg_start == 1) then (init, idle, do_always) -> run;
			else (idle, do_always) -> idle;
	@run	if (cycle <= (const_m - 2)) then (iteration, do_always) -> run;	// const_m - 2, last iteration is done in sfg end.
			else (end, idle, do_always) -> idle;
}

#endif /* MULT_MOD_FDL */
