#ifndef MALU_WRAPPER_FDL
#define MALU_WRAPPER_FDL

#include "constants.inc"

#include "malu.fdl"

/*
 * TODO: Problem when start is held high more than 1 cycle, for example
 *		reg_cycle will be kept at 0, even though the calculation has 
 *		already started.
 */

dp malu_wrapper (in A: ns(const_m);
	in B: ns(const_m);
	in start: ns(1);
	in mode: ns(1);
	out T: ns(const_m);
	out ready: ns(1)) {

	reg reg_start: ns(1);
	reg reg_mode: ns(1);

	reg reg_T: ns(const_m);
	reg reg_ready: ns(1);
	reg reg_m: ns(1);

	reg reg_A: ns(const_m);
	reg reg_B: ns(const_m);

	reg reg_cycle: ns(const_m);	// TODO: Too big, needs to be log2(const_m).

	sig T_in: ns(const_m);
	sig B_in: ns(const_m);
	sig m_in: ns(1);

	sig T_out: ns(const_m);
	sig m_out: ns(1);

	sig sig_end: ns(1);

	use malu(T_in, B_in, m_in, T_out, m_out);

	sfg do_always {
		reg_start = start;

		// Do it this way, so init doesn't waste a cycle.
		reg_mode = start == 1 ? mode : reg_mode;

		reg_A = start == 1 ? A : (reg_mode == 0 ? reg_A << 1 : reg_A);
		reg_B = start == 1 ? B : reg_B;

		reg_cycle = start == 1 ? 0 : reg_cycle + 1;

		// Store MALU output or reset reg_T when necessary.
		reg_T = start == 1 ? 0 : (sig_end == 1 ? m_out # ((ns(const_m - 	1)) T_out[1:(const_m - 1)]) : T_out);
		reg_m = m_out;

		// Set output depending on mode.
		T = reg_mode == 0 ? reg_T : reg_A ^ reg_B;

		reg_ready = start == 1 ? 0 : (sig_end == 1 ? 1 : reg_ready);	// TODO: Make this a logical expression.
		ready = reg_ready;
	}

	sfg idle {
		T_in = 0;
		B_in = 0;
		m_in = 0;

		sig_end = 0;
	}

	sfg iteration {
		T_in = reg_T;

		// And B instead of muxing: less area
		// reg_A[const_m - 1] is only ns(1), needs to be copied const_m times.
		B_in = ANDMBITS(reg_A[const_m - 1], reg_B);
		m_in = reg_m;

		sig_end = 0;
	
		//$display($bin, "reg_A[const_m - 1] = ", reg_A[const_m - 1], " - reg_m = ", reg_m, " - B_in = ", B_in, " - m_in = ", m_in, " - T_out = ", T_out, " - m_out = ", m_out);
	}

	sfg end_mult {
		T_in = reg_T;

		B_in = ANDMBITS(reg_A[const_m - 1], reg_B);
		m_in = reg_m;
		
		sig_end = 1;

		$display("[[End]] Output = T - T = ", $bin, reg_T, " = ", $dec, reg_T);
	}

	sfg end_add {
		T_in = 0;
		B_in = 0;
		m_in = 0;

		sig_end = 1;

		$display("[[End]] Output = T - T = ", $bin, reg_A ^ reg_B, " = ", $dec, reg_A ^ reg_B);
	}
}

fsm fsm_malu_wrapper (malu_wrapper) {
	initial idle;
	state run;

	@idle	if (reg_start == 1) then 
				if (reg_mode == 0) then (iteration, do_always) -> run;	// Multiplication
				else (end_add, do_always) -> idle;	// Addition
			else (idle, do_always) -> idle;
	@run	if (reg_cycle <= (const_m - 2)) then (iteration, do_always) -> run;	// const_m - 2, last iteration is done in sfg end.
			else (end_mult, do_always) -> idle;
}

#endif /* MALU_WRAPPER_FDL */
