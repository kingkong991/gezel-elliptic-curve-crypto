#ifndef GF2M_ADD_FDL
#define GF2M_ADD_FDL

#include "constants.inc"

#include "malu_wrapper.fdl"

/* Add 2 points on an elliptic curve. Points in projective coordinates:
 *	Output: Q(X, Y, Z) = P(X, Y, Z) * Q(X, Y, Z)
 *
 * Input: Input in 2 cycles, first P, then Q (or vice versa, doesn't matter of course)
 */
dp gf2m_add(in in_X:	ns(const_m);
	in in_Y:	ns(const_m);
	in in_Z:	ns(const_m);
	in start:	ns(1);
	out out_X:	ns(const_m);
	out out_Y:	ns(const_m);
	out out_Z:	ns(const_m);
	out ready:	ns(1)) {

	// Minimum amount of registers needed.
	reg P_X: ns(const_m);
	reg P_Y: ns(const_m);
	reg P_Z: ns(const_m);

	reg Q_X: ns(const_m);
	reg Q_Y: ns(const_m);
	reg Q_Z: ns(const_m);

	reg T1: ns(const_m);
	reg T2: ns(const_m);
	reg T3: ns(const_m);
	reg T4: ns(const_m);
	reg T5: ns(const_m);
	reg T6: ns(const_m);

	reg reg_start:	ns(1);
	reg reg_ready:	ns(1);
	
	reg reg_malu_ready: ns(1);

	// Signals for maluiplier.
	sig malu_A: ns(const_m);
	sig malu_B: ns(const_m);
	sig malu_C: ns(const_m);
	sig malu_start: ns(1);
	sig malu_mode: ns(1);
	sig malu_T:	ns(const_m);
	sig malu_ready: ns(1);

	use malu_wrapper(malu_A, malu_B, malu_C, malu_start, malu_mode, malu_T, malu_ready);
	
	sfg do_always {
		reg_start = start;

		out_X = Q_X;
		out_Y = Q_Y;
		out_Z = Q_Z;

		ready = reg_ready;

		reg_malu_ready = malu_ready;
	}

	sfg idle {
		malu_A = 0;
		malu_B = 0;
		malu_C = 0;

		malu_start = 0;
	}

	sfg init1 {
		reg_ready = 0;

		P_X = in_X;
		P_Y = in_Y;
		P_Z = in_Z;
	}

	sfg init2 {
		Q_X = in_X;
		Q_Y = in_Y;
		Q_Z = in_Z;
	}

	// All steps in order (algorithm Sakiyama 2.12)
	sfg step1 {
		malu_A = P_Z;
		malu_B = P_Z;
		malu_C = 0;

		malu_start = 1;
	}

	sfg step2 {
		malu_A = T6;
		malu_B = Q_X;
		malu_C = 0;

		malu_start = 1;
	}

	sfg step3 {
		malu_A = Q_Z;
		malu_B = Q_Z;
		malu_C = 0;

		malu_start = 1;
	}

	sfg step4 {
		malu_A = T2;
		malu_B = P_X;
		malu_C = T3;

		malu_start = 1;
	}

	sfg step5 {
		malu_A = T6;
		malu_B = P_Z;
		malu_C = 0;

		malu_start = 1;
	}

	sfg step6 {
		malu_A = T1;
		malu_B = Q_Y;
		malu_C = 0;

		malu_start = 1;
	}

	sfg step7 {
		malu_A = T2;
		malu_B = Q_Z;
		malu_C = 0;

		malu_start = 1;
	}

	sfg step8 {
		malu_A = T2;
		malu_B = P_Y;
		malu_C = T3;

		malu_start = 1;
	}

	// Save sfg's

	sfg save_X {
		Q_X = malu_T;
	}

	sfg save_Y {
		Q_Y = malu_T;
	}

	sfg save_Z {
		Q_Z = malu_T;
	}

	sfg save_T1 {
		T1 = malu_T;
	}

	sfg save_T2 {
		T2 = malu_T;
	}

	sfg save_T3 {
		T3 = malu_T;
	}

	sfg save_T4 {
		T4 = malu_T;
	}

	sfg save_T5 {
		T5 = malu_T;
	}

	sfg save_T6 {
		T6 = malu_T;
	}

	sfg end {
		reg_ready = 1;
	}

}

fsm fsm_gf2m_add (gf2m_add) {
	initial idle;
	state init;
	state step1, step2, step3, step4, step5, step6, step7, step8, step9, step10;
	state step11, step12, step13, step14, step15, step16, step17, step18, step19, step20;
	state end;

	@idle if (reg_start == 1) then (init1, do_always) -> init;
			else (idle, do_always) -> idle;
	@init (init2, step1, do_always) -> step1;	// TODO: Make sure this works (right now, step 1 doesn't use Q registers, so all is fine.
	@step1	if (reg_malu_ready == 1) then (save_T6, step2, do_always) -> step2;
				else (idle, do_always) -> step1;
	@step2	if (reg_malu_ready == 1) then (save_T3, step3, do_always) -> step3;
				else (idle, do_always) -> step2;
	@step3	if (reg_malu_ready == 1) then (save_T2, step4, do_always) -> step4;
				else (idle, do_always) -> step3;
	@step4	if (reg_malu_ready == 1) then (save_T4, step5, do_always) -> step5;
				else (idle, do_always) -> step4;
	@step5	if (reg_malu_ready == 1) then (save_T1, step6, do_always) -> step6;
				else (idle, do_always) -> step5;
	@step6	if (reg_malu_ready == 1) then (save_T3, step7, do_always) -> step7;
				else (idle, do_always) -> step6;
	@step7	if (reg_malu_ready == 1) then (save_T2, step8, do_always) -> step8;
				else (idle, do_always) -> step7;
	@step8	if (reg_malu_ready == 1) then (save_T1, step9, do_always) -> step9;
				else (idle, do_always) -> step8;
	@step9	if (reg_malu_ready == 1) then (save_T5, step10, do_always) -> step10;
				else (idle, do_always) -> step9;
	@step10	if (reg_malu_ready == 1) then (save_T3, step11, do_always) -> step11;
				else (idle, do_always) -> step10;
	@step11	if (reg_malu_ready == 1) then (save_T3, step11, do_always) -> step12;
				else (idle, do_always) -> step11;
	@step12	if (reg_malu_ready == 1) then (save_Z, step11, do_always) -> step13;
				else (idle, do_always) -> step12;
	@step13	if (reg_malu_ready == 1) then (save_T5, step11, do_always) -> step14;
				else (idle, do_always) -> step13;
	@step14	if (reg_malu_ready == 1) then (save_Y, step11, do_always) -> step15;
				else (idle, do_always) -> step14;
	@step15	if (reg_malu_ready == 1) then (save_T2, step11, do_always) -> step16;
				else (idle, do_always) -> step15;
	@step16	if (reg_malu_ready == 1) then (save_X, step11, do_always) -> step17;
				else (idle, do_always) -> step16;
	@step17	if (reg_malu_ready == 1) then (save_X, step11, do_always) -> step18;
				else (idle, do_always) -> step17;
	@step18	if (reg_malu_ready == 1) then (save_T4, step11, do_always) -> step19;
				else (idle, do_always) -> step18;
	@step19	if (reg_malu_ready == 1) then (save_T4, step11, do_always) -> step20;
				else (idle, do_always) -> step19;
	@step20	if (reg_malu_ready == 1) then (save_Y, end, do_always) -> idle;
				else (idle, do_always) -> step20;
}

#endif /* GF2M_ADD_FDL */

