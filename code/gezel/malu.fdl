dp malu (in T: ns(20);
	in B: ns(20);
	in P: ns(20);
	out T_n: ns(20);
	out m_n: ns(1)) {

	sig sum: ns(20);
	sig result: ns(20);

	sfg run {
		sum = T ^ B;
		result = sum ^ P;

		T_n = result[1:19]  # ((ns(1)) 0b0);
		m_n = result[20];
	}
} hardwired h_malu (malu) { run; }

dp montgomery (in A: ns(20);
	in B: ns(20);
	in P: ns(20);
	out T: ns(20);
	in start: ns(1)) {

	reg reg_start: ns(1);
	reg reg_T: ns(20);
	reg reg_m: ns(1);

	reg reg_A: ns(20);
	reg reg_B: ns(20);
	reg reg_P: ns(20);

	reg cycle:	ns(20);

	sig T_in: ns(20);
	sig B_in: ns(20);
	sig P_in: ns(20);

	sig T_out: ns(20);
	sig m_out: ns(1);

	use malu(T_in, B_in, P_in, T_out, m_out);

	sfg do_always {
		reg_start = start;
		T = reg_T;
	}

	sfg init {
		cycle = 0;

		reg_A = A >> 1;	// Shift, A[0] already used in this cycle
		reg_B = B;
		reg_P = P;

		T_in = 0;
		B_in = (A[0] == 0) ? 0 : B;
		P_in = 0;

		reg_T = T_out;
		reg_m = m_out;

		$display("[Iteration 0] Cycle = ", cycle, " - A = ", reg_A, " - B_in = ", B_in, " - T_out = ", T_out, " - m_out = ", m_out);
	}

	sfg idle {
		T_in = 0;
		B_in = 0;
		P_in = 0;
	}

	sfg iteration {
		T_in = reg_T;
		B_in = (reg_A[0] == 0) ? 0 : reg_B;
		P_in = (reg_m == 0) ? 0 : reg_P;
		
		cycle = cycle + 1;

		reg_T = T_out;
		reg_m = m_out;

		reg_A = reg_A >> 1;

		$display("[Iteration] Cycle = ", $dec, cycle, " - A = ", reg_A, " - B_in = ", B_in, " - T_out = ", T_out, " - m_out = ", m_out);
	}

	// "Divide" by x at the end
	sfg end {
		reg_T = (ns(1)) m_out # reg_T[1:19];

		$display("[End] reg_T = ", reg_T, " - T = ", T);
	}
}

fsm fsm_montgomery (montgomery) {
	initial idle;
	state run;

	@idle	if (reg_start == 1) then (init, do_always) -> run;	// How do I add iteration here?
			else (idle, do_always) -> idle;
	@run	if (cycle < 18) then (iteration, do_always) -> run;
			else (end, idle, do_always) -> idle;	// Cycle = 20 (start op 0, leest in als 18 en wordt zogezegd hier dan op 19 gezet)
}

dp testbench {
	sig A: ns(20);
	sig B: ns(20);
	sig P: ns(20);

	sig T: ns(20);

	sig start: ns(1);

	use montgomery(A, B, P, T, start);

	sfg run {
		A = 1;
		B = 3;
		P = 5;

		start = 1;

		$display("[Cycle ", $cycle, "]");
	}
} hardwired h_testbench (testbench) { run; }

system S {
	testbench;
}