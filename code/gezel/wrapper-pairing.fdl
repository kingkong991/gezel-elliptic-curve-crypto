#ifndef WRAPPER_PAIRING_FDL
#define WRAPPER_PAIRING_FDL

#include "constants.inc"

#include "wrapper_gf2m.fdl"

// Calculate E(P, Q)
// Output: f = E(P, Q)

dp wrapper_pairing(in input:	ns(const_m);
	in start:	ns(1);
	in next:	ns(1);
	out output:	ns(const_m);
	out ready:	ns(1)) {

	// Registers:
	reg reg_Xv: ns(const_m);
	reg reg_Yv: ns(const_m);

	reg reg_Xp: ns(const_m);
	reg reg_Yp: ns(const_m);

	reg reg_Xfa: ns(const_m);
	reg reg_Yfa: ns(const_m);

	reg reg_Ga: ns(const_m);
	reg reg_Gb: ns(const_m);

	reg reg_Fa: ns(const_m);
	reg reg_Fb: ns(const_m);
	reg reg_Fc: ns(const_m);
	reg reg_Fd: ns(const_m);

	reg reg_TmpA: ns(const_m);
	reg reg_TmpB: ns(const_m);

	reg reg_ToMALU: ns(const_m);

	reg reg_MALU_ready: ns(1);

	reg reg_count_miller: ns(const_m_log);
	reg reg_count_inverse: ns(const_m_log - 1);	// Max nr of consecutive squarings is +- half of const_m

	// GF2m core
	use wrapper_gf2m(sig_MALU_A, sig_MALU_B, sig_MALU_start, sig_MALU_mode, sig_MALU_result, sig_MALU_ready);

	// Signals
	// GF2m core signals
	sig sig_MALU_A: ns(const_m);
	sig sig_MALU_B: ns(const_m);
	sig sig_MALU_start: ns(1);
	sig sig_MALU_mode: ns(1);

	sig sig_MALU_result: ns(const_m);
	sig sig_MALU_ready: ns(1);

	// Input selection signals (for muxes)
	sig sig_sel_Xv: ns(2);
	sig sig_sel_Yv: ns(1);

	sig sig_sel_Xp: ns(1);
	sig sig_sel_Yp: ns(1);

	sig sig_sel_Xfa: ns(1);
	sig sig_sel_Yfa: ns(1);

	sig sig_sel_Ga: ns(1);
	sig sig_sel_Gb: ns(1);

	sig sig_sel_Fa: ns(1);
	sig sig_sel_Fb: ns(1);
	sig sig_sel_Fc: ns(1);
	sig sig_sel_Fd: ns(1);

	sig sig_sel_TmpA: ns(1);
	sig sig_sel_TmpB: ns(1);

	sig sig_sel_ToMALU: ns(2);

	// Data signals - To registers
	sig sig_to_Xv: ns(const_m);
	sig sig_to_Yv: ns(const_m);

	sig sig_to_Xp: ns(const_m);
	sig sig_to_Yp: ns(const_m);

	sig sig_to_Xfa: ns(const_m);
	sig sig_to_Yfa: ns(const_m);

	sig sig_to_Ga: ns(const_m);
	sig sig_to_Gb: ns(const_m);

	sig sig_to_Fa: ns(const_m);
	sig sig_to_Fb: ns(const_m);
	sig sig_to_Fc: ns(const_m);
	sig sig_to_Fd: ns(const_m);

	sig sig_to_TmpA: ns(const_m);
	sig sig_to_TmpB: ns(const_m);

	sig sig_to_ToMALU: ns(const_m);

	// Data signals - From registers
	sig sig_from_Xv: ns(const_m);
	sig sig_from_Yv: ns(const_m);

	sig sig_from_Xp: ns(const_m);
	sig sig_from_Yp: ns(const_m);

	sig sig_from_Xfa: ns(const_m);
	sig sig_from_Yfa: ns(const_m);

	sig sig_from_Ga: ns(const_m);
	sig sig_from_Gb: ns(const_m);

	sig sig_from_Fa: ns(const_m);
	sig sig_from_Fb: ns(const_m);
	sig sig_from_Fc: ns(const_m);
	sig sig_from_Fd: ns(const_m);

	sig sig_from_TmpA: ns(const_m);
	sig sig_from_TmpB: ns(const_m);

	sig sig_from_ToMALU: ns(const_m);
	sig sig_from_ToMALUShift: ns(const_m);

	// Misc signals
	sig sig_from_Input: ns(const_m);

	// SFG's
	sfg do_always {
		// Set misc registers
		reg_start = start;
		reg_next = next;

		// Set output - As long as not ready, set output to 0, else set to Xv.
		ready = reg_ready;
		output = reg_ready == 0 ? 0 : Xv;

		// GF2m MALU core signals
		sig_MALU_A = reg_ToMALU;
		sig_MALU_B = reg_Xv;

		reg_MALU_ready = sig_MALU_ready;

		// Set from_register signals
		sig_from_Xv = reg_Xv;
		sig_from_Yv = reg_Yv;

		sig_from_Xp = reg_Xp;
		sig_from_Yp = reg_Yp;
	
		sig_from_Xfa = reg_Xfa;
		sig_from_Yfa = reg_Yfa;
	
		sig_from_Ga = reg_Ga;
		sig_from_Gb = reg_Gb;
	
		sig_from_Fa = reg_Fa;
		sig_from_Fb = reg_Fb;
		sig_from_Fc = reg_Fc;
		sig_from_Fd = reg_Fd;
	
		sig_from_TmpA = reg_TmpA;
		sig_from_TmpB = reg_TmpB;
	
		sig_from_ToMALU = reg_ToMALU;
		sig_from_ToMALUShift = ((ns(const_m - 1)) reg_ToMALU[0:const_m - 2]) # ((ns(1)) reg_ToMALU[const_m - 1]);	// Circular left shift of reg_ToMALU

		sig_from_Input = input;

		// Set to_register signals
		sig_to_Xv = sig_sel_Xv == 0b10 ? sig_from_ToMALU : (sig_sel_Xv == 0b11 ? sig_from_Input : (sig_sel_Xv = 0b00 ? sig_from_TmpB : sig_from_Yv));
		sig_to_Yv = sig_sel_Yv == 0 ? sig_from_Xv : sig_from_Xp;
	
		sig_to_Xp = sig_sel_Xp == 0 ? sig_from_Yv : sig_from_Yp;
		sig_to_Yp = sig_sel_Yp == 0 ? sig_from_Xp : sig_from_Xfa;
	
		sig_to_Xfa = sig_sel_Xfa == 0 ? sig_from_Yp : sig_from_Yfa;
		sig_to_Yfa = sig_sel_Yfa == 0 ? sig_from_Xfa : sig_from_Ga;
	
		sig_to_Ga = sig_sel_Ga == 0 ? sig_from_Yfa : sig_from_Gb;
		sig_to_Gb = sig_sel_Gb == 0 ? sig_from_Ga : sig_from_Fa;
	
		sig_to_Fa = sig_sel_Fa == 0 ? sig_from_Gb : sig_from_Fb;
		sig_to_Fb = sig_sel_Fb == 0 ? sig_from_Fa : sig_from_Fc;
		sig_to_Fc = sig_sel_Fc == 0 ? sig_from_Fb : sig_from_Fd;
		sig_to_Fd = sig_sel_Fd == 0 ? sig_from_Fc : sig_from_TmpA;
	
		sig_to_TmpA = sig_sel_TmpA == 0 ? sig_from_Fd : sig_from_TmpB;
		sig_to_TmpB = sig_sel_TmpB == 0 ? sig_from_TmpA : sig_from_Xv;
	
		sig_to_ToMALU = sig_sel_ToMALU == 0b00 ? sig_from_Xv : (sig_sel_ToMALU == 0b01 ? sig_MALU_result : sig_from_ToMALUShift);
	}

	sfg idle_regs {
		// Set all enable signals to 0.
		sig_en_Xv = 0;
		sig_en_Yv = 0;
	
		sig_en_Xp = 0;
		sig_en_Yp = 0;
	
		sig_en_Xfa = 0;
		sig_en_Yfa = 0;
	
		sig_en_Ga = 0;
		sig_en_Gb = 0;
	
		sig_en_Fa = 0;
		sig_en_Fb = 0;
		sig_en_Fc = 0;
		sig_en_Fd = 0;
	
		sig_en_TmpA = 0;
		sig_en_TmpB = 0;
	
		sig_en_ToMALU = 0;

		// Set all select signals to 0.
		sig_sel_Xv = 0b00;
		sig_sel_Yv = 0;
	
		sig_sel_Xp = 0;
		sig_sel_Yp = 0;
	
		sig_sel_Xfa = 0;
		sig_sel_Yfa = 0;
	
		sig_sel_Ga = 0;
		sig_sel_Gb = 0;
	
		sig_sel_Fa = 0;
		sig_sel_Fb = 0;
		sig_sel_Fc = 0;
		sig_sel_Fd = 0;
	
		sig_sel_TmpA = 0;
		sig_sel_TmpB = 0;
	
		sig_sel_ToMALU = 0b00;
	}

	// Idle sfg's for individual registers
	sfg idle_Yv {
		sig_sel_Yv = 0;
	}

	sfg idle_Xp {
		sig_sel_Xp = 0;
	}

	sfg idle_Yp {
		sig_sel_Yp = 0;
	}

	sfg idle_Xfa {
		sig_sel_Xfa = 0;
	}

	sfg idle_Yfa {
		sig_sel_Yfa = 0;
	}

	sfg idle_Ga {
		sig_sel_Ga = 0;
	}

	sfg idle_Gb {
		sig_sel_Gb = 0;
	}

	sfg idle_Fa {
		sig_sel_Fa = 0;
	}

	sfg idle_Fb {
		sig_sel_Fb = 0;
	}

	sfg idle_Fc {
		sig_sel_Fc = 0;
	}

	sfg idle_Fd {
		sig_sel_Fd = 0;
	}

	sfg idle_TmpA {	
		sig_sel_TmpA = 0;
	}

	sfg idle_TmpB {
		sig_sel_TmpB = 0;
	}

	sfg idle_ToMALU {
		sig_sel_ToMALU = 0b00;
	}

	// SFG's for GF2m MALU core

	sfg MALU_idle {
		sig_MALU_start = 0;
		sig_MALU_mode = 0;
	}

	sfg MALU_add {
		sig_MALU_start = 1;
		sig_MALU_mode = 0;
	}

	sfg MALU_mult {
		sig_MALU_start = 1;
		sig_MALU_mode = 1;
	}

	// SFG's for individual data transfer
	sfg update_ToMALU_from_MALU {
		reg_ToMALU = sig_to_ToMALU;
		sig_sel_ToMALU = 0b01;
	}

	sfg update_ToMALU_from_Xv {
		reg_ToMALU = sig_to_ToMALU;
		sig_sel_ToMALU = 0b00;
	}

	sfg update_Xv_from_Input {
		reg_Xv = sig_to_Xv;
		sig_sel_Xv = 0b11;
	}

	sfg update_Xv_from_ToMALU {
		reg_Xv = sig_to_Xv;
		sig_sel_Xv = 0b10;
	}

	sfg update_Xv_from_Right {
		reg_Xv = sig_to_Xv;
		sig_sel_Xv = 0b01;
	}

	sfg update_Yv_from_Left {
		reg_Yv = sig_to_Yv;
		sig_sel_Xv = 0;
	}

	sfg update_Yv_from_Right {
		reg_Yv = sig_to_Yv;
		sig_sel_Xv = 1;
	}

	sfg update_Xp_from_Left {
		reg_Xp = sig_to_Xp;
		sig_sel_Xp = 0;
	}

	sfg update_Xp_from_Right {
		reg_Xp = sig_to_Xp;
		sig_sel_Xp = 1;
	}

	sfg update_Yp_from_Left {
		reg_Yp = sig_to_Yp;
		sig_sel_Yp = 0;
	}

	sfg update_Xfa_from_Left {
		reg_Xfa = sig_to_Xfa;
		sig_sel_Xfa = 0;
	}

	sfg update_Yfa_from_Left {
		reg_Yfa = sig_to_Yfa;
		sig_sel_Yfa = 0;
	}

	// SFG's to set data in registers
	sfg reset_F {
		reg_Fa = 1;
		reg_Fb = 0;
		reg_Fc = 0;
		reg_Fd = 0;
	}

	sfg reset_count_miller {
		reg_count_miller = const_m - 1;
	}

	sfg reset_count_inverse {
		reg_count_inverse = 0;
	}

	sfg inc_count_miller {
		reg_count_miller = reg_count_miller + 1;
	}

	sfg inc_count_inverse {
		reg_count_inverse = reg_count_inverse + 1;
	}

	// SFG's for ready signals
	sfg set_ready {
		reg_ready = 1;
	}

	sfg set_not_ready {
		reg_ready = 0;
	}
	
}

fsm fsm_wrapper_pairing (wrapper_pairing) {
	initial init1;
	state init2, init3, init4;

	// If start goes high, start the input loading cycle (see notebook). If start goes high again after inital raising edge, reset (= go to step 2).

	@init1	if (reg_start == 1) then (do_always, set_not_ready, update_Xv_from_Input, idle_Yv, idle_Xp, idle_Yp, idle_Xfa, idle_Yfa, idle_Ga, idle_Gb, idle_Fa, idle_Fb, idle_Fc, idle_Fd, idle_TmpA, idle_TmpB, idle_ToMALU, MALU_idle) -> init2;
			else (do_always, idle_regs, not_ready, MALU_idle) -> init1;

	@init2	if (reg_start == 1) then (do_always, not_ready, update_Xv_from_Input, idle_Yv, idle_Xp, idle_Yp, idle_Xfa, idle_Yfa, idle_Ga, idle_Gb, idle_Fa, idle_Fb, idle_Fc, idle_Fd, idle_TmpA, idle_TmpB, idle_ToMALU, MALU_idle) -> init2;
			else	if (reg_next == 1) then (do_always, update_Xv_from_Input, update_Yv_from_Left, idle_Xp, idle_Yp, idle_Xfa, idle_Yfa, idle_Ga, idle_Gb, idle_Fa, idle_Fb, idle_Fc, idle_Fd, idle_TmpA, idle_TmpB, idle_ToMALU, MALU_idle) -> init3;
					else (do_always, idle_regs, MALU_idle) -> init2;

	@init3	if (reg_start == 1) then (do_always, update_Xv_from_Input, idle_Yv, idle_Xp, idle_Yp, idle_Xfa, idle_Yfa, idle_Ga, idle_Gb, idle_Fa, idle_Fb, idle_Fc, idle_Fd, idle_TmpA, idle_TmpB, idle_ToMALU, MALU_idle) -> init2;
			else	if (reg_next == 1) then (do_always, update_Xv_from_Input, update_Yv_from_Left, update_Xp_from_Left, idle_Yp, idle_Xfa, idle_Yfa, idle_Ga, idle_Gb, idle_Fa, idle_Fb, idle_Fc, idle_Fd, idle_TmpA, idle_TmpB, idle_ToMALU, MALU_idle) -> init4;
					else (do_always, idle_regs, MALU_idle) -> init3;

	@init4	if (reg_start == 1) then (do_always, update_Xv_from_Input, idle_Yv, idle_Xp, idle_Yp, idle_Xfa, idle_Yfa, idle_Ga, idle_Gb, idle_Fa, idle_Fb, idle_Fc, idle_Fd, idle_TmpA, idle_TmpB, idle_ToMALU, MALU_idle) -> init2;
			else	if (reg_next == 1) then (do_always, update_Xv_from_Input, update_Yv_from_Left, update_Xp_from_Left, update_Yp_from_Left, idle_Xfa, idle_Yfa, idle_Ga, idle_Gb, idle_Fa, idle_Fb, idle_Fc, idle_Fd, idle_TmpA, idle_TmpB, update_ToMALU_from_Xv, MALU_idle) -> start;
					else (do_always, idle_regs, MALU_idle) -> init4;

	// Start the calculations
	
	// First calculate distortion map coordinates
	@start	(do_always, MALU_add, idle_regs) -> distort1;
	
	@distort1	if (reg_MALU_ready == 1) then (do_always, MALU_idle, update_ToMALU_from_MALU, idle_Xv, idle_Yv, idle_Xp, idle_Yp, idle_Xfa, idle_Yfa, idle_Ga, idle_Gb, idle_Fa, idle_Fb, idle_Fc, idle_Fd, idle_TmpA, idle_TmpB) -> distort2;
				else (do_always, idle_regs, MALU_idle) -> distort1;

	// Swap registers around so that everything is in it's correct location.
	@distort2	(do_always, MALU_idle, idle_ToMALU, update_Xv_from_ToMALU, idle_Yv, idle_Xp, idle_Yp, idle_Xfa, idle_Yfa, idle_Ga, idle_Gb, idle_Fa, idle_Fb, idle_Fc, idle_Fd, idle_TmpA, idle_TmpB) -> distort3;
	@distort3	(do_always, MALU_idle, idle_ToMALU, update_Xv_from_Right, update_Yv_from_Left, update_Xp_from_Right, update_Yp_from_Left, idle_Xfa, idle_Yfa, idle_Ga, idle_Gb, idle_Fa, idle_Fb, idle_Fc, idle_Fd, idle_TmpA, idle_TmpB) -> distort4;
	@distort4	(do_always, MALU_idle, idle_ToMALU, idle_Xv, update_Yv_from_Right, update_Xp_from_Left, idle_Yp, idle_Xfa, idle_Yfa, idle_Ga, idle_Gb, idle_Fa, idle_Fb, idle_Fc, idle_Fd, idle_TmpA, idle_TmpB) -> distort5;
	@distort5	(do_always, MALU_idle, idle_ToMALU, update_Xv_from_Right, update_Yv_from_Left, update_Xp_from_Right, update_Yp_from_Left, idle_Xfa, idle_Yfa, idle_Ga, idle_Gb, idle_Fa, idle_Fb, idle_Fc, idle_Fd, idle_TmpA, idle_TmpB) -> distort6;
	@distort6	(do_always, MALU_idle, idle_ToMALU, idle_Xv, update_Yv_from_Right, update_Xp_from_Left, idle_Yp, idle_Xfa, idle_Yfa, idle_Ga, idle_Gb, idle_Fa, idle_Fb, idle_Fc, idle_Fd, idle_TmpA, idle_TmpB) -> distort7;
	@distort7	(do_always, MALU_idle, idle_ToMALU, idle_Xv, update_Yv_from_Left, update_Xp_from_Left, update_Yp_from_Left, update_Xfa_from_Left, idle_Yfa, idle_Ga, idle_Gb, idle_Fa, idle_Fb, idle_Fc, idle_Fd, idle_TmpA, idle_TmpB) -> distort8;
	@distort8	(do_always, MALU_idle, idle_ToMALU, idle_Xv, idle_Yv, update_Xp_from_Left, update_Yp_from_Left, update_Xfa_from_Left, update_Yfa_from_Left, idle_Ga, idle_Gb, idle_Fa, idle_Fb, idle_Fc, idle_Fd, idle_TmpA, idle_TmpB) -> miller-init1;

	// Start Miller's algorithm for Tate pairing
	@miller-init1	(do_always, MALU_idle, reset_F, reset_count_miller, idle_ToMALU, idle_Xv, idle_Yv, update_Xp_from_Right, update_Yp_from_Left, idle_Xfa, idle_Yfa, idle_Ga, idle_Gb, idle_Fa, idle_Fb, idle_Fc, idle_Fd, idle_TmpA, idle_TmpB) -> miller-init2;
	@miller-init2	(do_always, MALU_idle, idle_ToMALU, idle_Xv, update_Yv_from_Right, update_Xp_from_Right, update_Yp_from_Left, idle_Xfa, idle_Yfa, idle_Ga, idle_Gb, idle_Fa, idle_Fb, idle_Fc, idle_Fd, idle_TmpA, idle_TmpB) -> miller1;

	// Start of main loop
	@miller1	if (reg_count_miller == 0) then (do_always, idle_regs, MALU_idle) -> final-exp1;
				else (do_always, inc_count_miller, 
	
	
}

idle all: idle_ToMALU, idle_Xv, idle_Yv, idle_Xp, idle_Yp, idle_Xfa, idle_Yfa, idle_Ga, idle_Gb, idle_Fa, idle_Fb, idle_Fc, idle_Fd, idle_TmpA, idle_TmpB
shift all left: idle_ToMALU, update_Xv_from_Left, update_Yv_from_Left, update_Xp_from_Left, update_Yp_from_Left, update_Xfa_from_Left, update_Yfa_from_Left, update_Ga_from_Left, update_Gb_from_Left, update_Fa_from_Left, update_Fb_from_Left, update_Fc_from_Left, update_Fd_from_Left, update_TmpA_from_Left, update_TmpB
shift all right: idle_ToMALU, update_Xv_from_Right, update_Yv_from_Right, update_Xp_from_Right, update_Yp_from_Right, update_Xfa_from_Right, update_Yfa_from_Right, update_Ga_from_Right, update_Gb_from_Right, update_Fa_from_Right, update_Fb_from_Right, update_Fc_from_Right, update_Fd_from_Right, update_TmpA_from_Right, update_TmpB

#endif /* WRAPPER_PAIRING_FDL */
