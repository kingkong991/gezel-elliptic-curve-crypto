#ifndef GF2M_ADD_AND_MULT_FDL
#define GF2M_ADD_AND_MULT_FDL

#include "constants.inc"

#include "malu_wrapper.fdl"

/* Calculate kP, with k >= 0 and P a point on the curve.
 *	Output: Q(X, Y) = k * P(X, Y)
 */
dp gf2m_add_and_mult(in in_X:	ns(const_m);
	in in_Y:	ns(const_m);
	in reset:	ns(1);
	in stop:		ns(1);
	in mode:		ns(2);
	out out_X:	ns(const_m);
	out out_Y:	ns(const_m);
	out ready:	ns(1)) {

	// Minimum amount of registers needed.
	reg reg_X: ns(const_m);
	reg reg_Y: ns(const_m);

	reg reg_k: ns(const_m);

	reg X1: ns(const_m);
	reg Z1: ns(const_m);
	reg X2: ns(const_m);
	reg Z2: ns(const_m);

	reg T1: ns(const_m);
	reg T2: ns(const_m);
	reg T3: ns(const_m);
	reg T4: ns(const_m);

	reg reg_reset: ns(1);
	reg reg_stop: ns(1);
	reg reg_mode: ns(2);

	reg reg_ready:	ns(1);
	
	reg reg_malu_ready: ns(1);

	sig sig_ready: ns(1);

	// Signals for the MALU.
	sig malu_A: ns(const_m);
	sig malu_B: ns(const_m);
	sig malu_start: ns(1);
	sig malu_mode: ns(1);
	sig malu_T:	ns(const_m);
	sig malu_ready: ns(1);

	use malu_wrapper(malu_A, malu_B, malu_start, malu_mode, malu_T, malu_ready);
	
	sfg do_always {
		reg_reset = reset;
		reg_stop = stop;
		reg_mode = mode;

		// Don't waste cycles in init
		reg_X = reset == 1 ? in_X : reg_X;
		reg_Y = reset == 1 ? in_Y : reg_Y;

		// Set output
		out_X = X2;
		out_Y = Z2;

		reg_ready = reset == 1 ? 0 : (sig_ready == 1 ? 1 : reg_ready);	// TODO: Make logical expression.
		ready = reg_ready;

		// If we start a calculation, set to 0, otherwise we get:
		// <calc done> -> reg = 1 -> <start calc> | <reg still 1> -> <reg set to 0> | <reg read as 1>
		//	And thus, the fsm will think the calculation  is ready, even though it's not.
		reg_malu_ready = malu_start == 1 ? 0 : malu_ready;
	}

	sfg idle {
		malu_A = 0;
		malu_B = 0;
		malu_mode = 0;

		malu_start = 0;
	}

	sfg init {
		X1 = reg_X;
		Z1 = 1;

		X2 = (ns(const_m - 2) reg_X << 2) # (ns(1) 0) # (ns(1) curve_B);	// X2 = x^4 + b
		Z2 = reg_X << 1;	// Z2 = x^2
	}

	/*
	 * All kinds of possible combinations of variables & calculations
	 */

	sfg mult_X1Z2 {
		malu_A = X1;
		malu_B = Z2;
		malu_mode = 0;
	}

	sfg mult_X2Z1 {
		malu_A = X2;
		malu_B = Z1;
		malu_mode = 0;
	}

	sfg mult_X1Z1 {
		malu_A = X1;
		malu_B = Z1;
		malu_mode = 0;
	}

	sfg add_X1Z1 {
		malu_A = X1;
		malu_B = Z1;
		malu_mode = 1;
	}

	sfg mult_Z1Z1 {
		malu_A = Z1;
		malu_B = Z1;
		malu_mode = 0;
	}

	sfg mult_Z1T1 {
		malu_A = Z1;
		malu_B = T1;
		malu_mode = 0;
	}

	sfg add_X1T2 {
		malu_A = X1;
		malu_B = T2;
		malu_mode = 1;
	}

	sfg mult_X1X1 {
		malu_A = X1;
		malu_B = X1;
		malu_mode = 0;		
	}

	sfg mult_X2X2 {
		malu_A = X2;
		malu_B = X2;
		malu_mode = 0;		
	}

	sfg mult_Z2Z2 {
		malu_A = Z2;
		malu_B = Z2;
		malu_mode = 0;		
	}

	sfg mult_Z2T1 {
		malu_A = Z2;
		malu_B = T1;
		malu_mode = 0;		
	}
	
	sfg mult_X2Z2 {
		malu_A = X2;
		malu_B = Z2;
		malu_mode = 0;		
	}

	sfg mult_T1T1 {
		malu_A = T1;
		malu_B = T1;
		malu_mode = 0;		
	}

	sfg add_X1T1 {
		malu_A = X1;
		malu_B = T1;
		malu_mode = 1;		
	}

	sfg add_X2T1 {
		malu_A = X2;
		malu_B = T1;
		malu_mode = 1;		
	}

	sfg add_X2Z2 {
		malu_A = X2;
		malu_B = Z2;
		malu_mode = 1;		
	}

	sfg add_X2T2 {
		malu_A = X2;
		malu_B = T2;
		malu_mode = 1;		
	}


	// Misc sfg's
	sfg malu_start {
		malu_start = 1;
	}

	sfg store_X_in_T1 {
		T1 = reg_X;
	}

	sfg store_C_in_T1 {
		T1 = (ns(const_m) curve_C);
	}

	sfg end {
		sig_ready = 1;
	}

	// Save sfg's
	sfg save_X1 {
		X1 = malu_T;
	}

	sfg save_Z1 {
		Z1 = malu_T;
	}

	sfg save_X2 {
		X2 = malu_T;
	}

	sfg save_Z2 {
		Z2 = malu_T;
	}

	sfg save_T1 {
		T1 = malu_T;
	}

	sfg save_T2 {
		T2 = malu_T;
	}
}

fsm fsm_gf2m_add_and_mult (gf2m_add_and_mult) {
	initial idle;
	state start

	state mode0_step2, mode0_step3, mode0_step4, mode0_step5, mode0_step6, mode0_step7, mode0_step8, mode0_step9;
	state mode0_step10, mode0_step11, mode0_step12, mode0_step13, mode0_step14, mode0_step15, mode0_step16, mode0_step17, mode0_step18, mode0_step19;
	state mode0_step20, mode0_step21, mode0_step22;

	state mode1_step2, mode1_step3, mode1_step4, mode1_step5, mode1_step6, mode1_step7, mode1_step8, mode1_step9;
	state mode1_step10, mode1_step11, mode1_step12, mode1_step13, mode1_step14, mode1_step15, mode1_step16, mode1_step17, mode1_step18, mode1_step19;
	state mode1_step20, mode1_step21, mode1_step22;

	state end;

	@idle if (reg_reset == 1) then (init, idle, do_always) -> start;
			else (idle, do_always) -> idle;

	@start	if (reg_stop == 1) then (idle, do_always) -> idle;
				else	if (reg_mode == 0) then (store_X_in_T1, mult_X2Z1, do_always, malu_start) -> mode0_step2;
						else (store_X_in_T1, mult_X1Z2, do_always, malu_start) -> mode1_step2;

	@mode0_step2	if (reg_malu_ready == 0) then (idle, do_always) -> mode0_step2;
						else (save_X2, mult_X1Z2, do_always, malu_start) -> mode0_step3;
	@mode0_step3	if (reg_malu_ready == 0) then (idle, do_always) -> mode0_step3;
						else (save_Z2, do_always) -> mode0_step4;	// We need new Z2 in next step, so we can't start calculation yet.
	@mode0_step4	(mult_X2Z2, do_always, malu_start) -> mode0_step5;
	@mode0_step5	if (reg_malu_ready == 0) then (idle, do_always) -> mode0_step5;
						else (save_T2, add_X2Z2, do_always, malu_start) -> mode0_step6;
	@mode0_step6	if (reg_malu_ready == 0) then (idle, do_always) -> mode0_step6;
						else (save_Z2, do_always) -> mode0_step7;
	@mode0_step7	(mult_Z2Z2, do_always, malu_start) -> mode0_step8;
	@mode0_step8	if (reg_malu_ready == 0) then (idle, do_always) -> mode0_step8;
						else (save_Z2, do_always) -> mode0_step9;
	@mode0_step9	(mult_Z2T1, do_always, malu_start) -> mode0_step10;
	@mode0_step10	if (reg_malu_ready == 0) then (idle, do_always) -> mode0_step10;
						else (save_X1, do_always) -> mode0_step11;
	@mode0_step11	(add_X2T2, do_always, malu_start) -> mode0_step12;
	@mode0_step12	if (reg_malu_ready == 0) then (idle, do_always) -> mode0_step12;
						else (save_X2, store_C_in_T1, mult_X1X1, do_always, malu_start) -> mode0_step13;
	@mode0_step13	if (reg_malu_ready == 0) then (idle, do_always) -> mode0_step13;
						else (save_X1, mult_Z1Z1, do_always, malu_start) -> mode0_step14;
	@mode0_step14	if (reg_malu_ready == 0) then (idle, do_always) -> mode0_step14;
						else (save_Z1, do_always) -> mode0_step15;
	@mode0_step15	(mult_Z1T1, do_always, malu_start) -> mode0_step16;
	@mode0_step16	if (reg_malu_ready == 0) then (idle, do_always) -> mode0_step16;
						else (save_T1, mult_X1Z1, do_always, malu_start) -> mode0_step17;
	@mode0_step17	if (reg_malu_ready == 0) then (idle, do_always) -> mode0_step17;
						else (save_Z1, mult_T1T1, do_always, malu_start) -> mode0_step18;	
	@mode0_step18	if (reg_malu_ready == 0) then (idle, do_always) -> mode0_step18;
						else (save_Z1, mult_T1T1, do_always, malu_start) -> mode0_step19;
	@mode0_step19	if (reg_malu_ready == 0) then (idle, do_always) -> mode0_step19;
						else (save_T1, mult_X1X1, do_always, malu_start) -> mode0_step20;
	@mode0_step20	if (reg_malu_ready == 0) then (idle, do_always) -> mode0_step20;
						else (save_X1, do_always) -> mode0_step21;
	@mode0_step21	(add_X1T1, do_always, malu_start) -> mode0_step22;
	@mode0_step22	if (reg_malu_ready == 0) then (idle, do_always) -> mode0_step22;
						else (save_X1, do_always, end) -> start;

	@mode1_step2	if (reg_malu_ready == 0) then (idle, do_always) -> mode1_step2;
						else (save_X1, mult_X2Z1, do_always, malu_start) -> mode1_step3;
	@mode1_step3	if (reg_malu_ready == 0) then (idle, do_always) -> mode1_step3;
						else (save_Z1, do_always) -> mode1_step4;	// We need new Z1 in next step, so we can't start calculation yet.
	@mode1_step4	(mult_X1Z1, do_always, malu_start) -> mode1_step5;
	@mode1_step5	if (reg_malu_ready == 0) then (idle, do_always) -> mode1_step5;
						else (save_T2, add_X1Z1, do_always, malu_start) -> mode1_step6;
	@mode1_step6	if (reg_malu_ready == 0) then (idle, do_always) -> mode1_step6;
						else (save_Z1, do_always) -> mode1_step7;
	@mode1_step7	(mult_Z1Z1, do_always, malu_start) -> mode1_step8;
	@mode1_step8	if (reg_malu_ready == 0) then (idle, do_always) -> mode1_step8;
						else (save_Z1, do_always) -> mode1_step9;
	@mode1_step9	(mult_Z1T1, do_always, malu_start) -> mode1_step10;
	@mode1_step10	if (reg_malu_ready == 0) then (idle, do_always) -> mode1_step10;
						else (save_X2, do_always) -> mode1_step11;
	@mode1_step11	(add_X1T2, do_always, malu_start) -> mode1_step12;
	@mode1_step12	if (reg_malu_ready == 0) then (idle, do_always) -> mode1_step12;
						else (save_X1, store_C_in_T1, mult_X2X2, do_always, malu_start) -> mode1_step13;
	@mode1_step13	if (reg_malu_ready == 0) then (idle, do_always) -> mode1_step13;
						else (save_X2, mult_Y1Y1, do_always, malu_start) -> mode1_step14;
	@mode1_step14	if (reg_malu_ready == 0) then (idle, do_always) -> mode1_step14;
						else (save_Y1, do_always) -> mode1_step15;
	@mode1_step15	(mult_Y1T1, do_always, malu_start) -> mode1_step16;
	@mode1_step16	if (reg_malu_ready == 0) then (idle, do_always) -> mode1_step16;
						else (save_T1, mult_X2Y1, do_always, malu_start) -> mode1_step17;
	@mode1_step17	if (reg_malu_ready == 0) then (idle, do_always) -> mode1_step17;
						else (save_Y1, mult_T1T1, do_always, malu_start) -> mode1_step18;	
	@mode1_step18	if (reg_malu_ready == 0) then (idle, do_always) -> mode1_step18;
						else (save_Y1, mult_T1T1, do_always, malu_start) -> mode1_step19;
	@mode1_step19	if (reg_malu_ready == 0) then (idle, do_always) -> mode1_step19;
						else (save_T1, mult_X2X2, do_always, malu_start) -> mode1_step20;
	@mode1_step20	if (reg_malu_ready == 0) then (idle, do_always) -> mode1_step20;
						else (save_X2, do_always) -> mode1_step21;
	@mode1_step21	(add_X2T1, do_always, malu_start) -> mode1_step22;
	@mode1_step22	if (reg_malu_ready == 0) then (idle, do_always) -> mode1_step22;
						else (save_X2, do_always, end) -> start;
}

#endif /* GF2M_ADD_AND_MULT_FDL */

