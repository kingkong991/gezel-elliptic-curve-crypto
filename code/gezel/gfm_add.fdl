#ifndef GMF_ADD_FDL
#define GMF_ADD_FDL

#include "constants.inc"

#include "mult_mod.fdl"

/* Add 2 points on an elliptic curve. Points in projective coordinates:
 *	Output: Q(X, Y, Z) = P(X, Y, Z) * Q(X, Y, Z)
 *
 * Input: Input in 2 cycles, first P, then Q (or vice versa, doesn't matter of course)
 */
dp gfm_add(in in_X:	ns(const_m);
	in in_Y:	ns(const_m);
	in in_Z:	ns(const_m);
	in start:	ns(1);
	out out_X:	ns(const_m);
	out out_Y:	ns(const_m);
	out out_Z:	ns(const_m);
	out ready:	ns(1)) {

	// Minimum amount of registers needed.
	reg P_X: ns(const_m);
	reg P_Y: ns(const_m);
	reg P_Z: ns(const_m);

	reg Q_X: ns(const_m);
	reg Q_Y: ns(const_m);
	reg Q_Z: ns(const_m);

	reg T1: ns(const_m);
	reg T2: ns(const_m);
	reg T3: ns(const_m);
	reg T4: ns(const_m);
	reg T5: ns(const_m);
	reg T6: ns(const_m);

	reg reg_start:	ns(1);
	reg reg_ready:	ns(1);
	
	// Signals for multiplier.
	sig mult_A: ns(const_m);
	sig mult_B: ns(const_m);
	sig mult_start: ns(1);
	sig mult_T:	ns(const_m);
	sig mult_ready: ns(1);

	sfg init1 {
		P_X = in_X;
		P_Y = in_Y;
		P_Z = in_Z;
	}

	use mult_mod(mult_A, mult_B, mult_start, mult_T, mult_ready);
	
	sfg do_always {
		reg_start = start;

		out_X = Q_X;
		out_Y = Q_Y;
		out_Z = Q_Z;

		ready = reg_ready;
	}

	sfg idle {
		mult_A = 0;
		mult_B = 0;
		mult_P = 0;

		mult_start = 0;
	}

	sfg init1 {
		reg_ready = 0;

		P_X = in_X;
		P_Y = in_Y;
		P_Z = in_Z;
	}

	sfg init2 {
		Q_X = in_X;
		Q_Y = in_Y;
		Q_Z = in_Z;
	}

	// All steps in order (algorithm 1)
	sfg step1 {

	}

	

	sfg end {
		reg_ready = 1;
	}

}

	

#endif /* GMF_ADD_FDL */

